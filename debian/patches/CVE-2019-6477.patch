Description: fix TCP Pipelining doesn't limit TCP clients on a single connection
Origin: backported from patch provided by ISC

--- a/bin/named/client.c
+++ b/bin/named/client.c
@@ -95,7 +95,15 @@
 #define SEND_BUFFER_SIZE		4096
 #define RECV_BUFFER_SIZE		4096
 
+#define TCP_CLIENTS_PER_CONN		23
+/*%<
+ * Number of simultaneous ns_clients_t (queries in flight) for one
+ * TCP connection.  The number was arbitrarily picked and might be
+ * changed in the future.
+ */
+
 #ifdef ISC_PLATFORM_USETHREADS
+
 #define NMCTXS				100
 /*%<
  * Number of 'mctx pools' for clients. (Should this be configurable?)
@@ -330,7 +338,7 @@ tcpconn_init(ns_client_t *client, isc_bo
 	 */
 	tconn = isc_mem_allocate(ns_g_mctx, sizeof(*tconn));
 
-	isc_refcount_init(&tconn->refs, 1);
+	isc_refcount_init(&tconn->clients, 1);	/* Current client */
 	tconn->tcpquota = quota;
 	quota = NULL;
 	tconn->pipelined = ISC_FALSE;
@@ -347,14 +355,14 @@ tcpconn_init(ns_client_t *client, isc_bo
  */
 static void
 tcpconn_attach(ns_client_t *source, ns_client_t *target) {
-	int refs;
+	int old_clients;
 
 	REQUIRE(source->tcpconn != NULL);
 	REQUIRE(target->tcpconn == NULL);
 	REQUIRE(source->tcpconn->pipelined);
 
-	isc_refcount_increment(&source->tcpconn->refs, &refs);
-	INSIST(refs > 1);
+	isc_refcount_increment(&source->tcpconn->clients, &old_clients);
+	INSIST(old_clients > 1);
 	target->tcpconn = source->tcpconn;
 }
 
@@ -367,15 +375,15 @@ tcpconn_attach(ns_client_t *source, ns_c
 static void
 tcpconn_detach(ns_client_t *client) {
 	ns_tcpconn_t *tconn = NULL;
-	int refs;
+	int old_clients;
 
 	REQUIRE(client->tcpconn != NULL);
 
 	tconn = client->tcpconn;
 	client->tcpconn = NULL;
 
-	isc_refcount_decrement(&tconn->refs, &refs);
-	if (refs == 0) {
+	isc_refcount_decrement(&tconn->clients, &old_clients);
+	if (old_clients == 0) {
 		isc_quota_detach(&tconn->tcpquota);
 		isc_mem_free(ns_g_mctx, tconn);
 	}
@@ -2614,28 +2622,39 @@ client_request(isc_task_t *task, isc_eve
 	/*
 	 * Pipeline TCP query processing.
 	 */
-	if (TCP_CLIENT(client) &&
-	    client->message->opcode != dns_opcode_query)
-	{
-		client->tcpconn->pipelined = ISC_FALSE;
-	}
-	if (TCP_CLIENT(client) && client->tcpconn->pipelined) {
+	if (TCP_CLIENT(client)) {
+		if (client->message->opcode != dns_opcode_query) {
+			client->tcpconn->pipelined = ISC_FALSE;
+		}
+
 		/*
-		 * We're pipelining. Replace the client; the
-		 * replacement can read the TCP socket looking
-		 * for new messages and this one can process the
-		 * current message asynchronously.
-		 *
-		 * There will now be at least three clients using this
-		 * TCP socket - one accepting new connections,
-		 * one reading an existing connection to get new
-		 * messages, and one answering the message already
-		 * received.
+		 * Limit the maximum number of simultaneous pipelined
+		 * queries on TCP connection to TCP_CLIENTS_PER_CONN.
 		 */
-		result = ns_client_replace(client);
-		if (result != ISC_R_SUCCESS) {
+		if ((isc_refcount_current(&client->tcpconn->clients)
+			    > TCP_CLIENTS_PER_CONN))
+		{
 			client->tcpconn->pipelined = ISC_FALSE;
 		}
+
+		if (client->tcpconn->pipelined) {
+			/*
+			 * We're pipelining. Replace the client; the
+			 * replacement can read the TCP socket looking
+			 * for new messages and this one can process the
+			 * current message asynchronously.
+			 *
+			 * There will now be at least three clients using this
+			 * TCP socket - one accepting new connections,
+			 * one reading an existing connection to get new
+			 * messages, and one answering the message already
+			 * received.
+			 */
+			result = ns_client_replace(client);
+			if (result != ISC_R_SUCCESS) {
+				client->tcpconn->pipelined = ISC_FALSE;
+			}
+		}
 	}
 
 	dns_opcodestats_increment(ns_g_server->opcodestats,
--- a/bin/named/include/named/client.h
+++ b/bin/named/include/named/client.h
@@ -74,7 +74,10 @@
 
 /*% reference-counted TCP connection object */
 typedef struct ns_tcpconn {
-	isc_refcount_t		refs;
+	isc_refcount_t		clients;	/* Number of clients using
+						 * this connection. Conn can
+						 * be freed if goes to 0
+						 */
 	isc_quota_t		*tcpquota;
 	isc_boolean_t		pipelined;
 } ns_tcpconn_t;
